using MaterialSymbolsParser.Extensions;
using MaterialSymbolsParser.Model;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis;

namespace MaterialSymbolsParser.Service;

public class CodeGenerationService
{
    public void GenerateCsFilesUsingRoslyn(Dictionary<string, IReadOnlyCollection<Icon>> groupedIcons, string folder)
    {
        foreach (var group in groupedIcons)
        {
            var family = group.Key;
            var className = Utility.FamilyMap.FamilyNameToCsharpClassName(family);
            var familyPath = Utility.FamilyMap.FamilyNameToHtmlClassName(family);

            var namespaceDeclaration = GenerateUsingsAndNamespace(group, className, familyPath);
            var code = namespaceDeclaration.NormalizeWhitespace().ToFullString();

            var path = Path.Combine(folder, $"{className}.cs");
            FileInfo file = new FileInfo(path);
            file.Directory?.Create();
            File.WriteAllText(path, code);
        }
    }

    private static CompilationUnitSyntax GenerateUsingsAndNamespace(KeyValuePair<string, IReadOnlyCollection<Icon>> group, string className, string familyPath)
    {
        var usings = SyntaxFactory.List(new[]
        {
            SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System"))
        });

        var namespaceDeclaration = SyntaxFactory
            .NamespaceDeclaration(SyntaxFactory.ParseName("MudBlazor"))
            .AddMembers(GenerateIconsClass(group, className, familyPath));

        var commentTrivia = AddComment();

        return SyntaxFactory.CompilationUnit()
            .WithUsings(usings)
            .WithMembers(SyntaxFactory.SingletonList<MemberDeclarationSyntax>(namespaceDeclaration))
            .WithLeadingTrivia(commentTrivia); ;
    }

    private static SyntaxTriviaList AddComment()
    {
        var commentText = $"This file was auto-generated by MaterialSymbolsParser {DateTime.Now:yyyy/MM/dd_HH:mm:ss}";
        return SyntaxFactory.TriviaList(
            SyntaxFactory.Comment($"/*\n * {commentText}\n */"),
            SyntaxFactory.CarriageReturnLineFeed,
            SyntaxFactory.CarriageReturnLineFeed
        );
    }

    private static ClassDeclarationSyntax GenerateIconsClass(KeyValuePair<string, IReadOnlyCollection<Icon>> group, string className, string familyPath)
    {
        return SyntaxFactory.ClassDeclaration("Icons")
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.StaticKeyword), SyntaxFactory.Token(SyntaxKind.PartialKeyword))
            .AddMembers(GenerateMaterialSymbolsClass(group, className, familyPath));
    }

    private static ClassDeclarationSyntax GenerateMaterialSymbolsClass(KeyValuePair<string, IReadOnlyCollection<Icon>> group, string className, string familyPath)
    {
        return SyntaxFactory.ClassDeclaration("MaterialSymbols")
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.StaticKeyword), SyntaxFactory.Token(SyntaxKind.PartialKeyword))
            .AddMembers(GenerateFamilyClass(group, className, familyPath));
    }

    private static ClassDeclarationSyntax GenerateFamilyClass(KeyValuePair<string, IReadOnlyCollection<Icon>> group, string className, string familyPath)
    {
        return SyntaxFactory.ClassDeclaration(className)
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.StaticKeyword), SyntaxFactory.Token(SyntaxKind.PartialKeyword))
            .AddMembers(group.Value.Select(icon => GenerateIconField(icon, familyPath)).Cast<MemberDeclarationSyntax>().ToArray());
    }

    private static bool IsKeyword(string keyword)
    {
        var syntaxKind = SyntaxFacts.GetKeywordKind(keyword);
        return SyntaxFacts.IsKeywordKind(syntaxKind);
    }

    private static FieldDeclarationSyntax GenerateIconField(Icon icon, string familyPath)
    {
        var iconName = icon.Name.ConvertToCamelCase();
        if (char.IsDigit(iconName[0]))
        {
            iconName = $"_{iconName}";
        }

        if (IsKeyword(iconName))
        {
            iconName = $"@{iconName}";
        }

        return SyntaxFactory.FieldDeclaration(
                SyntaxFactory.VariableDeclaration(SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.StringKeyword)))
                    .AddVariables(
                        SyntaxFactory.VariableDeclarator(iconName)
                            .WithInitializer(SyntaxFactory.EqualsValueClause(
                                SyntaxFactory.LiteralExpression(
                                    SyntaxKind.StringLiteralExpression,
                                    SyntaxFactory.Literal($"{familyPath}/{icon.Name}")
                                )
                            ))
                    )
            )
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.ConstKeyword));
    }
}