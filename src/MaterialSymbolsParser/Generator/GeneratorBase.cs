using MaterialSymbolsParser.Extensions;
using MaterialSymbolsParser.Model.Google;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis;

namespace MaterialSymbolsParser.Generator;

public abstract class GeneratorBase : IGenerator
{
    public abstract string Namespace { get; }

    public CompilationUnitSyntax GetCompilationUnitSyntax(KeyValuePair<string, IReadOnlyCollection<Icon>> group, string className, string familyPath)
    {
        var usings = SyntaxFactory.List(new[]
        {
            SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System"))
        });

        var namespaceDeclaration = SyntaxFactory
            .NamespaceDeclaration(SyntaxFactory.ParseName(Namespace))
            .AddMembers(GenerateFamilyClass(group, className, familyPath));

        var commentTrivia = AddComment();

        return SyntaxFactory.CompilationUnit()
            .WithUsings(usings)
            .WithMembers(SyntaxFactory.SingletonList<MemberDeclarationSyntax>(namespaceDeclaration))
            .WithLeadingTrivia(commentTrivia);
    }

    private static SyntaxTriviaList AddComment()
    {
        var commentText = $"This file was auto-generated by MaterialSymbolsParser {DateTime.Now:yyyy/MM/dd_HH:mm:ss}";
        return SyntaxFactory.TriviaList(
            SyntaxFactory.Comment($"/*\n * {commentText}\n */"),
            SyntaxFactory.CarriageReturnLineFeed,
            SyntaxFactory.CarriageReturnLineFeed
        );
    }

    /*
    Only if we want use nested classes like its currently done in MudBlazor, but we actually should use namespace and do a breaking changed in MudBlazor 

    private static ClassDeclarationSyntax GenerateIconsClass(KeyValuePair<string, IReadOnlyCollection<Icon>> group, string className, string familyPath)
    {
        return SyntaxFactory.ClassDeclaration("Icons")
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.StaticKeyword), SyntaxFactory.Token(SyntaxKind.PartialKeyword))
            .AddMembers(GenerateMaterialSymbolsClass(group, className, familyPath));
    }

    private static ClassDeclarationSyntax GenerateMaterialSymbolsClass(KeyValuePair<string, IReadOnlyCollection<Icon>> group, string className, string familyPath)
    {
        return SyntaxFactory.ClassDeclaration("MaterialSymbols")
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.StaticKeyword), SyntaxFactory.Token(SyntaxKind.PartialKeyword))
            .AddMembers(GenerateFamilyClass(group, className, familyPath));
    }
    */

    private static ClassDeclarationSyntax GenerateFamilyClass(KeyValuePair<string, IReadOnlyCollection<Icon>> group, string className, string familyPath)
    {
        return SyntaxFactory.ClassDeclaration(className)
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.StaticKeyword), SyntaxFactory.Token(SyntaxKind.PartialKeyword))
            .AddMembers(group.Value.Select(icon => GenerateIconField(icon, familyPath)).Cast<MemberDeclarationSyntax>().ToArray());
    }

    private static bool IsKeyword(string keyword)
    {
        var syntaxKind = SyntaxFacts.GetKeywordKind(keyword);
        return SyntaxFacts.IsKeywordKind(syntaxKind);
    }

    private static FieldDeclarationSyntax GenerateIconField(Icon icon, string familyPath)
    {
        var iconName = icon.Name.ConvertToCamelCase();
        if (char.IsDigit(iconName[0]))
        {
            iconName = $"_{iconName}";
        }

        if (IsKeyword(iconName))
        {
            iconName = $"@{iconName}";
        }

        return SyntaxFactory.FieldDeclaration(
                SyntaxFactory.VariableDeclaration(SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.StringKeyword)))
                    .AddVariables(
                        SyntaxFactory.VariableDeclarator(iconName)
                            .WithInitializer(SyntaxFactory.EqualsValueClause(
                                SyntaxFactory.LiteralExpression(
                                    SyntaxKind.StringLiteralExpression,
                                    SyntaxFactory.Literal($"{familyPath}/{icon.Name}")
                                )
                            ))
                    )
            )
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.ConstKeyword));
    }
}