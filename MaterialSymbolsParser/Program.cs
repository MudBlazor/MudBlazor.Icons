using System.Text.Json;
using MaterialSymbolsParser.Model;
using MaterialSymbolsParser.Service;
using Microsoft.CodeAnalysis;
//using MaterialSymbolsParser.Model;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using IconMetadata = MaterialSymbolsParser.Model.Metadata;

namespace MaterialSymbolsParser;

internal class Program
{
    public const string MaterialSymbolsPrefix = "Material Symbols";

    static async Task Main(string[] args)
    {
        using var client = new IconHttpClient();
        //string url = "http://fonts.google.com/metadata/icons?incomplete=1&key=material_symbols";
        //IconMetadata? metadata = await FetchAndParseMetadataAsync(url);
        var metadata = await client.ParseIconsAsync();
        var filteredIcons = FilterNonMaterialSymbols(metadata!);
        var groupedIcons = GroupIconsByFamilies(filteredIcons);
        GenerateCsFilesUsingRoslyn(groupedIcons);
    }

    public static void GenerateCsFilesUsingRoslyn(Dictionary<string, List<Icon>> groupedIcons)
    {
        //var familyNamesMap = new Dictionary<string, string>
        //{
        //    { "Material Symbols Outlined", "Outlined" },
        //    { "Material Symbols Rounded", "Rounded" },
        //    { "Material Symbols Sharp", "Sharp" }
        //};

        //var familyPathsMap = new Dictionary<string, string>
        //{
        //    { "Material Symbols Outlined", "material-symbols-outlined" },
        //    { "Material Symbols Rounded", "material-symbols-rounded" },
        //    { "Material Symbols Sharp", "material-symbols-sharp" }
        //};

        foreach (var group in groupedIcons)
        {
            string family = group.Key;
            string className = Utility.FamilyMap.FamilyNameToCsharpClassName(family);
            string familyPath = Utility.FamilyMap.FamilyNameToHtmlClassName(family);

            // Generate the code
            var namespaceDeclaration = GenerateNamespace(group, className, familyPath);
            var code = namespaceDeclaration.NormalizeWhitespace().ToFullString();

            // Write to file
            File.WriteAllText($"{className}.cs", code);
        }
    }

    private static NamespaceDeclarationSyntax GenerateNamespace(KeyValuePair<string, List<Icon>> group, string className, string familyPath)
    {
        return SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName("MudBlazor"))
            .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System")))
            .AddMembers(GenerateIconsClass(group, className, familyPath))
            .WithLeadingTrivia(AddComment());
    }

    private static SyntaxTriviaList AddComment()
    {
        string commentText = $"This file was auto-generated by MaterialSymbolsParser {DateTime.Now:yyyy/MM/dd_HH:mm:ss}";
        return SyntaxFactory.TriviaList(
            SyntaxFactory.Comment($"/*\n * {commentText}\n */"),
            SyntaxFactory.CarriageReturnLineFeed,
            SyntaxFactory.CarriageReturnLineFeed
        );
    }

    private static ClassDeclarationSyntax GenerateIconsClass(KeyValuePair<string, List<Icon>> group, string className, string familyPath)
    {
        return SyntaxFactory.ClassDeclaration("Icons")
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.PartialKeyword))
            .AddMembers(GenerateMaterialSymbolsClass(group, className, familyPath));
    }

    private static ClassDeclarationSyntax GenerateMaterialSymbolsClass(KeyValuePair<string, List<Icon>> group, string className, string familyPath)
    {
        return SyntaxFactory.ClassDeclaration("MaterialSymbols")
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.PartialKeyword))
            .AddMembers(GenerateFamilyClass(group, className, familyPath));
    }

    private static ClassDeclarationSyntax GenerateFamilyClass(KeyValuePair<string, List<Icon>> group, string className, string familyPath)
    {
        return SyntaxFactory.ClassDeclaration(className)
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.PartialKeyword))
            .AddMembers(group.Value.Select(icon => GenerateIconField(icon, familyPath)).Cast<MemberDeclarationSyntax>().ToArray());
    }
    private static FieldDeclarationSyntax GenerateIconField(Icon icon, string familyPath)
    {
        string iconName = icon.Name;
        if (char.IsDigit(iconName[0]))
        {
            iconName = "_" + iconName;
        }

        return SyntaxFactory.FieldDeclaration(
                SyntaxFactory.VariableDeclaration(SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.StringKeyword)))
                    .AddVariables(
                        SyntaxFactory.VariableDeclarator(iconName)
                            .WithInitializer(SyntaxFactory.EqualsValueClause(
                                SyntaxFactory.LiteralExpression(
                                    SyntaxKind.StringLiteralExpression,
                                    SyntaxFactory.Literal($"{familyPath}/{icon.Name}")
                                )
                            ))
                    )
            )
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.ConstKeyword));
    }

    public static Dictionary<string, List<Icon>> GroupIconsByFamilies(List<Icon> icons)
    {
        var families = new List<string>
        {
            "Material Symbols Outlined",
            "Material Symbols Rounded",
            "Material Symbols Sharp"
        };

        var groupedIcons = new Dictionary<string, List<Icon>>();

        foreach (var family in families)
        {
            groupedIcons[family] = icons
                .Where(icon => !icon.UnsupportedFamilies.Contains(family))
                .ToList();
        }

        return groupedIcons;
    }

    //public static void GenerateCsFiles(Dictionary<string, List<Icon>> groupedIcons)
    //{
    //    var familyNamesMap = new Dictionary<string, string>
    //    {
    //        { "Material Symbols Outlined", "Outlined" },
    //        { "Material Symbols Rounded", "Rounded" },
    //        { "Material Symbols Sharp", "Sharp" }
    //    };

    //    var familyPathsMap = new Dictionary<string, string>
    //    {
    //        { "Material Symbols Outlined", "material-symbols-outlined" },
    //        { "Material Symbols Rounded", "material-symbols-rounded" },
    //        { "Material Symbols Sharp", "material-symbols-sharp" }
    //    };

    //    foreach (var group in groupedIcons)
    //    {
    //        string family = group.Key;
    //        string className = familyNamesMap[family];
    //        string familyPath = familyPathsMap[family];
    //        StringBuilder sb = new StringBuilder();

    //        sb.AppendLine("namespace MudBlazor");
    //        sb.AppendLine("{");
    //        sb.AppendLine("    public partial class Icons");
    //        sb.AppendLine("    {");
    //        sb.AppendLine("        public partial class MaterialSymbols");
    //        sb.AppendLine("        {");
    //        sb.AppendLine($"            public partial class {className}");
    //        sb.AppendLine("            {");

    //        foreach (var icon in group.Value)
    //        {
    //            string iconName = icon.Name;
    //            if (char.IsDigit(iconName[0]))
    //            {
    //                iconName = "_" + iconName;
    //            }
    //            sb.AppendLine($"                public const string {iconName} = \"{familyPath}/{icon.Name}\";");
    //        }

    //        sb.AppendLine("            }");
    //        sb.AppendLine("        }");
    //        sb.AppendLine("    }");
    //        sb.AppendLine("}");

    //        // Write the string builder content to a .cs file
    //        File.WriteAllText($"{className}.cs", sb.ToString());
    //    }
    //}

    public static List<Icon> FilterNonMaterialSymbols(IconMetadata metadata)
    {
        return metadata.Icons
            .Where(icon => !icon.UnsupportedFamilies.Any(family => family.StartsWith(MaterialSymbolsPrefix)))
            .ToList();
    }

    public static async Task<IconMetadata?> FetchAndParseMetadataAsync(string url)
    {
        using HttpClient client = new HttpClient();
        var json = await client.GetStringAsync(url);

        using var reader = new StringReader(json);
        await reader.ReadLineAsync(); // Skip the first line
        var validJson = await reader.ReadToEndAsync();

        var metadata = JsonSerializer.Deserialize<IconMetadata>(validJson, new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        });

        return metadata;
    }
}