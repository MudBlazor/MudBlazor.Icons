using MaterialSymbolsParser.Model;
using MaterialSymbolsParser.Service;
using Microsoft.CodeAnalysis;
//using MaterialSymbolsParser.Model;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace MaterialSymbolsParser;

public class Program
{
    static async Task Main(string[] args)
    {
        using var client = new IconHttpClientService();
        var metadata = await client.ParseIconsAsync();
        var filteredIcons = Utility.IconFilter.FilterNonMaterialSymbols(metadata!);
        var groupedIcons = Utility.IconFilter.GroupIconsByFamilies(filteredIcons);
        GenerateCsFilesUsingRoslyn(groupedIcons);
    }

    public static void GenerateCsFilesUsingRoslyn(Dictionary<string, IReadOnlyCollection<Icon>> groupedIcons)
    {
        foreach (var group in groupedIcons)
        {
            string family = group.Key;
            string className = Utility.FamilyMap.FamilyNameToCsharpClassName(family);
            string familyPath = Utility.FamilyMap.FamilyNameToHtmlClassName(family);

            // Generate the code
            var namespaceDeclaration = GenerateNamespace(group, className, familyPath);
            var code = namespaceDeclaration.NormalizeWhitespace().ToFullString();

            // Write to file
            File.WriteAllText($"{className}.cs", code);
        }
    }

    private static FileScopedNamespaceDeclarationSyntax GenerateNamespace(KeyValuePair<string, IReadOnlyCollection<Icon>> group, string className, string familyPath)
    {
        return SyntaxFactory.FileScopedNamespaceDeclaration(SyntaxFactory.ParseName("MudBlazor"))
            .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System")))
            .AddMembers(GenerateIconsClass(group, className, familyPath))
            .WithLeadingTrivia(AddComment());
    }

    private static SyntaxTriviaList AddComment()
    {
        string commentText = $"This file was auto-generated by MaterialSymbolsParser {DateTime.Now:yyyy/MM/dd_HH:mm:ss}";
        return SyntaxFactory.TriviaList(
            SyntaxFactory.Comment($"/*\n * {commentText}\n */"),
            SyntaxFactory.CarriageReturnLineFeed,
            SyntaxFactory.CarriageReturnLineFeed
        );
    }

    private static ClassDeclarationSyntax GenerateIconsClass(KeyValuePair<string, IReadOnlyCollection<Icon>> group, string className, string familyPath)
    {
        return SyntaxFactory.ClassDeclaration("Icons")
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.PartialKeyword))
            .AddMembers(GenerateMaterialSymbolsClass(group, className, familyPath));
    }

    private static ClassDeclarationSyntax GenerateMaterialSymbolsClass(KeyValuePair<string, IReadOnlyCollection<Icon>> group, string className, string familyPath)
    {
        return SyntaxFactory.ClassDeclaration("MaterialSymbols")
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.PartialKeyword))
            .AddMembers(GenerateFamilyClass(group, className, familyPath));
    }

    private static ClassDeclarationSyntax GenerateFamilyClass(KeyValuePair<string, IReadOnlyCollection<Icon>> group, string className, string familyPath)
    {
        return SyntaxFactory.ClassDeclaration(className)
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.PartialKeyword))
            .AddMembers(group.Value.Select(icon => GenerateIconField(icon, familyPath)).Cast<MemberDeclarationSyntax>().ToArray());
    }
    private static FieldDeclarationSyntax GenerateIconField(Icon icon, string familyPath)
    {
        string iconName = icon.Name;
        if (char.IsDigit(iconName[0]))
        {
            iconName = "_" + iconName;
        }

        return SyntaxFactory.FieldDeclaration(
                SyntaxFactory.VariableDeclaration(SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.StringKeyword)))
                    .AddVariables(
                        SyntaxFactory.VariableDeclarator(iconName)
                            .WithInitializer(SyntaxFactory.EqualsValueClause(
                                SyntaxFactory.LiteralExpression(
                                    SyntaxKind.StringLiteralExpression,
                                    SyntaxFactory.Literal($"{familyPath}/{icon.Name}")
                                )
                            ))
                    )
            )
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.ConstKeyword));
    }

    //public static void GenerateCsFiles(Dictionary<string, List<Icon>> groupedIcons)
    //{
    //    var familyNamesMap = new Dictionary<string, string>
    //    {
    //        { "Material Symbols Outlined", "Outlined" },
    //        { "Material Symbols Rounded", "Rounded" },
    //        { "Material Symbols Sharp", "Sharp" }
    //    };

    //    var familyPathsMap = new Dictionary<string, string>
    //    {
    //        { "Material Symbols Outlined", "material-symbols-outlined" },
    //        { "Material Symbols Rounded", "material-symbols-rounded" },
    //        { "Material Symbols Sharp", "material-symbols-sharp" }
    //    };

    //    foreach (var group in groupedIcons)
    //    {
    //        string family = group.Key;
    //        string className = familyNamesMap[family];
    //        string familyPath = familyPathsMap[family];
    //        StringBuilder sb = new StringBuilder();

    //        sb.AppendLine("namespace MudBlazor");
    //        sb.AppendLine("{");
    //        sb.AppendLine("    public partial class Icons");
    //        sb.AppendLine("    {");
    //        sb.AppendLine("        public partial class MaterialSymbols");
    //        sb.AppendLine("        {");
    //        sb.AppendLine($"            public partial class {className}");
    //        sb.AppendLine("            {");

    //        foreach (var icon in group.Value)
    //        {
    //            string iconName = icon.Name;
    //            if (char.IsDigit(iconName[0]))
    //            {
    //                iconName = "_" + iconName;
    //            }
    //            sb.AppendLine($"                public const string {iconName} = \"{familyPath}/{icon.Name}\";");
    //        }

    //        sb.AppendLine("            }");
    //        sb.AppendLine("        }");
    //        sb.AppendLine("    }");
    //        sb.AppendLine("}");

    //        // Write the string builder content to a .cs file
    //        File.WriteAllText($"{className}.cs", sb.ToString());
    //    }
    //}
}